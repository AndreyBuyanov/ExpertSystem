#include "Tree.hpp"

#include "ILogger.hpp"

namespace ES
{

/**
 * Получение корня дерева.
 *
 * \return Корень дерева
 */
BasicNode* Tree::GetRoot() const noexcept
{
    // Возвращаем корень дерева
    return m_root;
}

/**
 *  Добавление узла, имеющего тип "Вопрос".
 * 
 * \param question Конфигурация узла
 * \return 
 */
void Tree::AddQuestion(
    const NodeConfig& question) noexcept
{
    // Создаём новый узел типа "Вопрос"
    // it - итератор, указывающий на созданный узел
    // result - результат создания узла.
    // Если узел уже существует, то создание нового не произойдёт.
    auto [it, result] = m_nodesStorage.emplace(question.id, std::make_unique<Question>(question));
    // Проверяем результат
    if (!result) {
        // Такой узел уже есть. Выведем предупреждение.
        // В конфигурации системы оказались узлы, имеющие одинаковый идентификатор.
        // Система будет работать, но узлы с одинаковыми идентификаторами - это неправильно.
        logger->Log(LogLevel::Warning, u8"Вопрос с идентификатором "
            + std::to_string(question.id)
            + u8" уже существует");
    }
    // Будем считать, что первый вызов данного метода добавляет корневой узел
    // TODO: Возможно следует как-то помечать корневой узел в конфигурационном файле
    // Если корневой узел ещё не задан,
    if (!m_root) {
        // то сделаем вновь созданный узел корневым
        m_root = it->second.get();
    }
}

/**
 * Добавление узла, имеющего тип "Ответ".
 * 
 * \param answer Конфигурация узла
 * \return 
 */
void Tree::AddAnswer(
    const NodeConfig& answer) noexcept
{
    // Создаём новый узел типа "Ответ"
    // it - итератор, указывающий на созданный узел
    // result - результат создания узла.
    // Если узел уже существует, то создание нового не произойдёт.
    auto [_, result] = m_nodesStorage.emplace(answer.id, std::make_unique<Answer>(answer));
    // Проверяем результат
    if (!result) {
        // Такой узел уже есть. Выведем предупреждение.
        // В конфигурации системы оказались узлы, имеющие одинаковый идентификатор.
        // Система будет работать, но узлы с одинаковыми идентификаторами - это неправильно.
        logger->Log(LogLevel::Warning, u8"Ответ с идентификатором "
            + std::to_string(answer.id)
            + u8" уже существует");
    }
}

/**
 * Добавление соединения между узлами.
 * Перед вызовом данного метода неободимо
 * добавить вопросы и ответы с помощью методов
 * AddQuestion и AddAnswer
 * 
 * \param connection Конфигурация соединения
 * \return 
 */
void Tree::AddConnection(
    const ConnectionConfig& connection) noexcept
{
    // Среди всех узлов ищем узел, соответствующий идентификатору источника.
    // Найденный узел будет родительским
    auto src = m_nodesStorage.find(connection.src);
    // Проверяем результат поиска
    if (src == m_nodesStorage.end()) {
        // Узла с заданным идентификатором не нашлось.
        // Система сможет работать, но в конфигурации ошибка
        logger->Log(LogLevel::Warning, u8"Узел с идентификатором "
            + std::to_string(connection.src)
            + u8" не найден");
        // Игнорируем данное соединение, просто выходим из функции
        return;
    }
    // Если найденный узел является ответом,
    // то у него не может быть дочерних узлов,
    // тк ответы являются конечными элементами дерева.
    if (src->second->Type() == NodeType::Answer) {
        // Система сможет работать, но в конфигурации ошибка
        logger->Log(LogLevel::Warning, u8"Неправильный тип узла");
        // Игнорируем данное соединение, просто выходим из функции
        return;
    }
    // Среди всех узлов ищем узел, соответствующий идентификатору приёмника.
    // Найденный узел будет дочерним по отношению к узлу
    // с идентификатором connection.src
    auto dst = m_nodesStorage.find(connection.dst);
    // Проверяем результат поиска
    if (dst == m_nodesStorage.end()) {
        // Узла с заданным идентификатором не нашлось.
        // Система сможет работать, но в конфигурации ошибка
        logger->Log(LogLevel::Warning, u8"Узел с идентификатором "
            + std::to_string(connection.dst)
            + u8" не найден");
        // Игнорируем данное соединение, просто выходим из функции
        return;
    }
    // Кастуем BasicNode к Question
    auto srcQuestion = dynamic_cast<Question*>(src->second.get());
    // Добавляем соединение с дочерним узлом к соответствующему вопросу
    srcQuestion->AddConnection(dst->second.get(), connection.predicat);
}

}
